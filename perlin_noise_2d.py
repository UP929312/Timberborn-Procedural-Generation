# -*- coding: utf-8 -*-
"""
Created on Tues Oct 12 23:13:25 2021

@author: Skezza
"""

import numpy as np

def interpolant(t):
    return t*t*t*(t*(t*6 - 15) + 10)

def generate_perlin_noise_2d(shape, res):
    """Generate a 2D numpy array of perlin noise.
    Args:
        shape: The width and length of the array
        res: The number of periods of noise to generate along each
            axis (tuple of two ints). Note shape must be a multiple of
            res.
    Returns:
        A numpy array of the generated noise.
    """
    delta = (res[0] / shape[0], res[1] / shape[1])
    d = (shape[0] // res[0], shape[1] // res[1])
    grid = np.mgrid[0:res[0]:delta[0], 0:res[1]:delta[1]]\
             .transpose(1, 2, 0) % 1
    # Gradients
    angles = 2*np.pi*np.random.rand(res[0]+1, res[1]+1)
    gradients = np.dstack((np.cos(angles), np.sin(angles)))
    gradients = gradients.repeat(d[0], 0).repeat(d[1], 1)
    g00 = gradients[    :-d[0],    :-d[1]]
    g10 = gradients[d[0]:     ,    :-d[1]]
    g01 = gradients[    :-d[0],d[1]:     ]
    g11 = gradients[d[0]:     ,d[1]:     ]
    # Ramps
    n00 = np.sum(np.dstack((grid[:,:,0]  , grid[:,:,1]  )) * g00, 2)
    n10 = np.sum(np.dstack((grid[:,:,0]-1, grid[:,:,1]  )) * g10, 2)
    n01 = np.sum(np.dstack((grid[:,:,0]  , grid[:,:,1]-1)) * g01, 2)
    n11 = np.sum(np.dstack((grid[:,:,0]-1, grid[:,:,1]-1)) * g11, 2)
    # Interpolation
    t = interpolant(grid)
    n0 = n00*(1-t[:,:,0]) + t[:,:,0]*n10
    n1 = n01*(1-t[:,:,0]) + t[:,:,0]*n11
    return np.sqrt(2)*((1-t[:,:,1])*n0 + t[:,:,1]*n1)

def generate_fractal_noise_2d(map_length, map_width, res, octaves=1, persistence=0.5,
                              lacunarity=2, frequency=1, amplitude=1):
    """Generate a 2D numpy array of fractal noise.
    Args:
        shape: (int, int), The shape of the generated array (tuple of two ints).
            This must be a multiple of lacunarity**(octaves-1)*res.
        res: (int, int), The number of periods of noise to generate along each
            axis (tuple of two ints). Note shape must be a multiple of
            (lacunarity**(octaves-1)*res).
        octaves: int The number of octaves in the noise. Defaults to 1.
        persistence: The scaling factor between two octaves.
        lacunarity: The frequency factor between two octaves.
        frequency: ???
        amplitude: float, the steepness and height of mountains and dips
    Returns:
        A numpy array of fractal noise and of shape shape generated by
        combining several octaves of perlin noise.
    Raises:
        ValueError: If (map_length, map_width) are not multiples of
            (lacunarity**(octaves-1)*res).
    """
    shape = (map_length, map_width)
    noise = np.zeros((map_length, map_width))
    for _ in range(octaves):
        noise += amplitude * generate_perlin_noise_2d(shape, (frequency*res[0], frequency*res[1]))
        frequency *= lacunarity
        amplitude *= persistence
    return noise


def normalize(config, map_object, map_length, map_width, minimum, maximum):
    # Turn from -1 to 1 to -min to +max
    for x_axis in range(map_length):
        for z_axis in range(map_width):
            map_object[x_axis, z_axis] = int(map_object[x_axis, z_axis] * (0.5*(maximum-minimum)))  # Get the difference, and split into 2

    # Get the minimum/lowest point
    map_minimum = map_object.min()
    # Find the difference between the maps minimum and the desired minimum
    difference = minimum-map_minimum
    # Shift every point in the map object up by the difference (NumPy allows you to easily do this using the `+` operator)
    map_object = map_object + difference
    # By default, the types will be numpy floats, so we need to convert them to ints, otherwise the game will crash when seeing 15.0
    result = map_object.astype(int)

    return np.clip(result, 1, config["terrain_height_limit"])  # We need to stop the terrain going out of bounds, so <= 16, or 64 if using the mod


def generate_map_array(map_length, map_width, config):
    # Generate a 2d noise map from -1 to 1, size being map_length by map_width
    noise_map = generate_fractal_noise_2d(map_length=map_length, map_width=map_width, res=(8, 8), octaves=config["octaves"], persistence=config["persistence"], lacunarity=config["lacunarity"], frequency=config["frequency"], amplitude=config["amplitude"])

    # Our perlin noise is in range -1 to 1, so we need to make it
    # in the range of min_height to max_height
    normalized_map = normalize(config, noise_map, map_length, map_width, minimum=config["min_height"], maximum=config["max_height"])

    return normalized_map
    
